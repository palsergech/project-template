# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

commonAnnotations: {}

commonLabels: {}

kind: Deployment

replicaCount: 1

image:
  repository: generic.registry/path/to/service-image
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

updateStrategy:
  type: RollingUpdate

podManagementPolicy: OrderedReady

# override command and args
command: []
args: []

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

podSecurityContext: {}
# fsGroup: 2000

securityContext:
  capabilities:
    drop:
      - ALL
  runAsUser: 1042
  runAsGroup: 1042
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false

service:
  enabled: true
  type: ClusterIP
  clusterIP: ""
  containerPorts:
    http: 8000
  ports:
    http: 80
  annotations: {}
  multiple:
    enabled: false

lifecycle: {}

metrics:
  enabled: false
  portName: http
  path: /metrics
  serviceMonitor:
    enabled: false
    additionalLabels: {}
    ## The label to use to retrieve the job name from.
    ## jobLabel: "app.kubernetes.io/name"
    namespace: ""
    namespaceSelector: {}
    ## Default: scrape .Release.Namespace only
    ## To scrape all, use the following:
    ## namespaceSelector:
    ##   any: true
    scrapeInterval: 30s
    # honorLabels: true
    targetLabels: []
    relabelings: []
    metricRelabelings: []

sidecars: []
  # - name: postgres
  #   image: docker.io/postgres:15
  #   imagePullPolicy: IfNotPresent
  #   command: []
  #   args: []
  #   startupProbe: {}
  #   readinessProbe: {}
  #   livenessProbe: {}
  #   resources: {}
  #   lifecycle: {}
  #   volumeMounts: {}
  #   ports:
  #     - name: postgres
  #       containerPort: 5432
#       protocol: TCP

ingresses: []
  # - name: main
  #   port: 80
  #   className: ""
  #   labels:
  #     my-key: my-value
  #   annotations:
  #     # kubernetes.io/ingress.class: nginx
  #     kubernetes.io/tls-acme: "true"
  #   hosts:
  #     - host: chart-example.local
  #       paths:
  #         - path: /
  #           pathType: ImplementationSpecific
  #   tls:
  #    - secretName: chart-example-tls
  #      hosts:
#        - chart-example.local

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
#   memory: 128Mi

nodeSelector: {}

tolerations: []

affinity: {}

startupProbe:
  httpGet:
    path: /health
    port: 80
    scheme: HTTP
  initialDelaySeconds: 10
  timeoutSeconds: 5
  periodSeconds: 5
  successThreshold: 1
  failureThreshold: 15

livenessProbe:
  httpGet:
    path: /health
    port: 80
    scheme: HTTP
  timeoutSeconds: 5
  periodSeconds: 10
  successThreshold: 1
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready
    port: 80
    scheme: HTTP
  timeoutSeconds: 5
  periodSeconds: 30
  successThreshold: 1
  failureThreshold: 2

envVars: []
  # - name: INSTANCE_ID
  #   value: "{{ .serviceIndex }}"
envSecretVars: {}

extraEnvVars: []
extraEnvSecretVars: {}
extraVolumeMounts: []
extraVolumes: []
